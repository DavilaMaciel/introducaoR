---
title: "Indexação e Lógica"
subtitle: "Nicholas A. C. Marino"
author: "nac.marino@gmail.com"
date: "github.com/nacmarino/introducaoR"
output: html_document
---

<style type="text/css">
body, td {
   font-size: 18px;
}
code.r{
  font-size: 16px;
}
pre {
  font-size: 16px
}
h1,h2,h3,h4,h5,h6{
  font-size: 24pt;
}
</style>

# Elementos da Aula

1. Criando vetores - Parte 2;
2. Indexação de Vetores e Data Frames;
3. Operadores de Lógica;
4. Operações Condicionais em Vetores;
5. Operações Condicionais em `data.frame`.
6. Outras Operações Condicionais.
7. Aplicações da Indexação e Operações Condicionais.

## Criando vetores - Parte 2

* Podemos criar um vetor ao listarmos uma sequência de valores.

```{r}
(exemplo <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
```

* No entanto, as vezes é mais útil automatizarmos a criação destas sequências, para evitar erros ou o trabalho repetitivo. 
* Uma forma de fazer isso é através da função `seq`.

```{r}
# cria uma sequência de 1 a 10, em intervalos de uma unidade
seq(from = 1, to = 10, by = 1)
# cria uma sequência de 20 número de 1 a 10
seq(from = 1, to = 10, length.out = 20)
```

* Também podemos pedir ao R para que repita uma sequência de valores através da função `rep`.

```{r}
# repetir a sequência 1, 2, 3, 4 duas vezes
rep(x = c(1, 2, 3, 4, 5), 2)
# repetir duas vezes em sequência cada elemento do vetor 1, 2, 3, 4 
rep(x = c(1, 2, 3, 4, 5), each = 2)
```

* Outra forma de fazer isso é através da utilização do operador ":" entre valores: tudo o que está no intervalo x:y (x a y) deve ser impresso.

```{r}
# cria uma sequência de 1 a 10
1:10
# cria uma sequência de 23 a 51
23:51
```

* Podemos criar um vetor utilizando este operador.

```{r}
(vetor1 <- 1:100)
```

* Nós podemos determinar o tamanho de um vetor (assim como o número de colunas em um `data.frame`) através da função `length`.

```{r}
length(vetor1)
```

##### Exercício 1

a. Crie dois vetores de mesmo comprimento:
    + Um deles deve ser feito através através da indexação;
    + O outro deve ser criado através da função `seq`.
b. Junte estes dois vetores em um único vetor, com o nome do objeto de `vetores`;
c. Qual o comprimento do vetor?
d. Crie um vetor com as letras "A" e "B", em sequência, cada uma repetida metade das vezes do comprimento total dos vetores;
e. Junte três dois vetores em um data.frame, com cada vetor sendo uma coluna diferente - crie o objeto `dados`;
f. Qual o comprimento do data.frame? O que este comprimento representa?

* Eu vou fazer as três primeiras partes do exercício também:

```{r}
# vetor 1
vetor1 <- 1:34
# vetor 2
vetor2 <- seq(from = 0, to = 100, length.out = 34)
# juntando os dois vetores em um só
vetores <- c(vetor1, vetor2)
# criando vetor de letras
letras <- rep(c("A", "B"), each = 17)
# juntando os dois vetores em um data.frame
dados <- data.frame(vetor1, vetor2, letras)
```

* Com este vetor e `data.frame` tão longos, como podemos fazer para extrair apenas alguns pedaços de interesse maior para trabalharmos?

## Indexação de Vetores e Data Frames

* Indexação é a ação de extrair um elemento específico, ou um conjunto de elementos, de um objeto.
* Cada objeto criado pode ser descrito por um conjunto de dimensões (copie e rode os exemplos junto de cada caso abaixo):
    1. um `vector` possui apenas uma dimensão: o seu comprimento linear.
        + `vetor1`
    2. uma `matrix` possui duas dimensões: as linhas e as coluna:
        + `matrix(c(vetor1, vetor2), ncol = 2)`
        + um `array` é um caso especial de matriz com mais de duas dimensões: e.g. `array(0, dim = c(2, 4, 3))`
    3. uma `list` possui uma ou mais dimensões: sub-listas, compostas por uma ou sub-listas e as dimensões dos objetos que as compõem:
        + `list(vetor1, vetor2, list(vetor1, vetor2), list(list(vetor1, vetor2), vetor1))`
    4. um `data.frame` possui apenas duas dimensões: as linhas e as colunas:
        + `data.frame(vetor1, vetor2)`
        
* Note que, em cada um destes casos, cada elemento pode ser rastreado até uma posição específica. Por exemplo:
    + no `vetor1` que criamos anteriormente, o número 7 ocupa a sétima posição na sequência;
    + em `list(vetor1, vetor2)`, o número 100 ocupa a 34a. posição da segunda lista;
    + em `data.frame(vetor1, vetor2)`, o número 0 ocupa a primeira linha a segunda coluna.
* Assim, como em um jogo de batalha naval, podemos extrair sub-conjuntos específicos de dados de acordo com as 'coordenadas' dos dados que queremos.
* Para tal, utilizaremos três tipos de operadores:
    1. `[]`  extrai um ou mais elementos em vetores, listas, ou `data.frame`;
    2. `[[]]` extrai um ou mais elementos em listas ou `data.frame`;
    3. `$` extrai elementos pelo __nome__ em listas e `data.frame`.

### Indexando Vetores

* Por exemplo, se quisermos extrair o 16o. elemento do `vetor2`, podemos usar:

```{r}
vetor2[16]
```

* Podemos extrair sequências de elementos em um vetor de forma similar àquela que usamos acima:

```{r}
# extraindo do 16o. ao 21o. elemento do vetor2
vetor2[16:21]
```

* Mas o que estamos fazendo ao fornecer esta sequência de números? Compare:

```{r}
# criando uma sequência de número de 16 a 21
(numeros <- 16:21)
# indexando o vetor2 para extrair do 16o. ao 21o. elemento
vetor2[16:21]
# indexando o vetor2 para extrair os valores de acordo com a sequencia criada
vetor2[numeros]
```

* A indexação está usando um vetor de um ou mais elementos - este vetor marca a posição dos elementos a serem retidos.  
* Assim, poderíamos criar um vetor com números representando posições específicas que queremos reter:

```{r}
numeros <- c(1, 5, 7, 9)
vetor2[numeros]
```

##### Exercício 2

a. Utilizando o `vetor2`, faça uma indexação que retorne:
    1. Os cinco primeiros elementos;
    2. Os elementos nas posições 10, 12, 14, 16, 18 e 20;
    3. Os cinco primeiros elementos e os elementos entre as posições 20 e 30;
    4. Apenas os elementos em posição par.

* Da mesma forma como podemos selecionar os elementos que __queremos__, podemos selecionar aqueles elementos que __não queremos__!

```{r}
# excluindo o segundo elemento
vetor2[-2]
# excluindo os elementos nas posicoes 1, 5, 7, 9
numeros # vetor que criamos anteriormente
vetor2[-numeros]
```

* Para excluirmos uma sequência contínua de valores devemos concatenar estes valores primeiro, caso contrário o R não entende que queremos eliminar uma sequência de posições.

```{r}
vetor2[-c(1:20)]
```

##### Exercício 3

a. Exclua todos os elementos em posição ímpar do `vetor2`.  

### Indexando `data.frame`

* Mas e para indexarmos um data.frame?
* Lembre-se que um `data.frame` possui duas dimensões: linhas e colunas.
    + A indexação do `data.frame` deve então considerar estas duas dimensões;
    + A metáfora do jogo de batalha naval é especialmente válida para um `data.frame`: [linha, coluna]

```{r}
# apenas a primeira linha do data.frame dados
dados[1,]
# apenas a primeira coluna do data.frame dados
dados[,1]
# apenas o elemento da primeira linha e primeira coluna do data.frame dados
dados[1,1]
# podemos usar o operar [[]] para indexar as colunas de um data.frame
dados[[3]]
```

##### Exercício 4

a. Usando o data.frame `dados`:
    1. Selecione as linhas de número 3, 12, 18 e 25, retendo todas as colunas;
    2. Selecione apenas as colunas 2 e 3, linhas 20 a 30;
    3. Selecione toda colunas, mas apenas as linhas pares;
    4. Elimine apenas a coluna 3;
    5. Elimine as linhas 15 a 30.

* Também podemos indexar um conjunto de dados em um `data.frame` através do nome da coluna ou da sub-lista.

```{r}
dados[, c("vetor2", "letras")]
```

* Outra forma de indexar uma coluna de um `data.frame` é através do indexador `$`.

```{r}
dados$letras
```

* __Dica do RStudio:__ ao tentar indexar um objeto através do uso do `$`, digite o nome do objeto, adicione o `$` e pressione `Tab` - todos os elementos que compõem a estrutura daquele elemento estarão disponíveis.

### Indexando listas

* E para indexarmos uma lista?

```{r}
# vamos criar, primeiro, uma lista
lista <- list(vetor2, dados)
# vamos observar a lista
lista
```

* Note que os elementos da lista são marcados como `[[1]]` e `[[2]]`, respectivamente.

```{r}
# para observar o primeiro elemento da lista
lista[[1]]
# para observar o segundo elemento da lista
lista[[2]]
```

* Logo, se quisermos selecionar algum elemento de uma das sub-listas devemos primeiro selecionar a sub-lista para, então, selecionar o elemento.  

```{r}
# selecionando a segunda e terceira coluna da segunda sub-lista
lista[[2]][,c(2:3)]
```

##### Exercício 5

a. Selecione os elementos nas posições pares do objeto na primeira sub-lista de `lista`.

## Operadores de Lógica

* Apesar de reter ou eliminar posições específicas de um objeto no R ser algo útil, na maior parte das vezes queremos realizar esta tarefa para conjuntos dos dados que cumpram certos requerimentos (por exemplo, reter apenas as observações de uma determinada categoria).
* Uma forma de fazer isto é através de testes lógicos.
* Existem 8 operadores de lógica na linguagem R: 

Operador | Significado
-------- | ------------
>        | maior que 
>=       | maior que ou igual a
<        | menor que
<=       | menor que ou igual a
==       | igualdade
!=       | diferença
&        | "e"
"\|"     | "ou"

* O uso da maior parte destes operadores é razoável para nós:

```{r}
# o número 4 é maior do que o 5?
4 > 5
# um número 4 é menor do que o 5?
4 < 5
# o número 4 é igual ao 5?
4 == 5
# o número 4 é diferente do 5?
4 != 5
# uma palavra é igual a outra?
"Ola" == "Tchau"
"Ola" == "Ola"
# uma palavra é diferente da outra?
"Ola" != "Tchau"
"Ola" != "Ola"
```

* Um caso um pouco mais complexo é determinarmos se um elemento cumpre com uma ou mais condições:

```{r}
# o número 4 é maior que o 5 E é menor que o 3?
4 > 5 & 4 < 3
# o número 4 é menor que o 5 E é maior que o 3?
4 < 5 & 4 > 3
# o número 4 é maior do que 5 OU é menor do que 3?
4 > 5 | 4 < 3
# o número 4 é maior do que 5 OU é menor do que 3?
4 < 5 | 4 > 3
```

##### Exercício 6

a. Sem olhar, qual valor o teste lógico `4 > 5 | 4 > 3` deve assumir?
b. A sua expectativa corresponde ao resultado do teste lógico?
c. Qual a explicação para isso?

* Como podemos observar, estes operadores de lógica funcionam bem para sabermos se um elemento passa em um determinado teste.
* Uma forma de usar isso ao nosso favor é:
    + se um elemento passar em um determinado teste, retenha este elemento;
    + se um elemento não passar em um determinado teste, elimine este elemento.
* Agora, veremos como podemos usar estes critérios para realizar operações condicionais com vetores e `data.frame`.

## Operações Condicionais em Vetores

* Assim como podemos testar se um elemento atende a uma determina condição, também podemos testar _quais elementos de um vetor atendem a uma determinada condição_.

```{r}
# quais elementos do vetor1 são maiores que 10?
vetor1 > 10
# quais elementos do vetor1 são menores ou iguais a 10?
vetor1 <= 10
```

* Podemos usar a mesma lógica para retermos caracteres que assumam determinados valores:

```{r}
# quais das letras são iguais a A
letras == "A"
# quais das letras não são iguais a A
letras != "B"
```

##### Exercício 7

a. Quais elementos do `vetor1` são menores do que 10 e maiores do que 25?
b. Quais elementos do `vetor1` são maiores de 15 (inclusive) ou menores do que 3?

* Uma coisa importante a se notar é que ao fazermos estes testes, __o resultado retornado é um vetor__.

```{r}
# quais os valores do vetor1 maiores que 17?
(maior17 <- vetor1 > 17)
# este teste lógico é um vetor?
is.vector(x = maior17)
```

* Portanto, podemos usar estes testes lógicos para indexar vetores também.

```{r}
# retornando elementos do vetor1 que sejam maiores que 17
vetor1[maior17]
# outra forma de fazer isso:
vetor1[vetor1 > 17]
```

* Além disso, podemos usar um vetor para indexar um outro vetor, desde que eles tenham o mesmo tamanho.
```{r}
# supondo que os valores do vetor1 correspondem as valores das categorias em letras
# quais as categorias de letras são iguais a "B"?
letraB <- letras == "B"
# quais os elementos do vetor1 pertencem à categoria letra "B"?
vetor1[letraB]
```

##### Exercício 8

a. Crie um vetor de número de 1 a 100 e guarde este vetor em um objeto.
b. Crie um segundo vetor com duas categorias: "impar" e "par" (nesta ordem), e guarde em um objeto.
c. Faça com que os valores "impar" e "par" sejam repetidos 50 vezes, de forma intercalada ("impar", "par", "impar", "par", ...); guarde isso em um objeto.
d. Indexe o vetor criado no passo "a" de forma que somente os números __pares__ sejam apresentados.

* O que este último exercício nos mostra é que podemos usar condições relacionadas a um vetor para indexar valores em um outro vetor. Isto é um passo importante para entendermos as operações condicionais em um `data.frame`.

## Operações Condicionais em `data.frame`

## Outras operações condicionais


* Além destes testes lógicos diretos, o R possui um conjunto de funções que são empregadas exclusivamente para testes lógicos: `is.na`, `is.infinite`, `is.nan`, `setequal`, `setdiff`, `which`, `which.min`, `which.max`, `ifelse`.

* As funções `is.na`, `is.inf`, `is.nan` são usadas para determinar a existência de `NA`, `Inf` e `NaN` em um vetor: assim como os testes lógicos em vetores, estas funções retornam valores de `TRUE` ou `FALSE` para os valores que passam ou não no teste lógico.

```{r}
# criando um vetor com NA e testando sua existência
vetor3 <- c(3, 6, NA, 12, 15)
is.na(vetor3)
# criando um vetor com Inf e testando sua existência
vetor4 <- c(9, 4, 1, Inf, 0)
is.infinite(vetor4)
# criando com NaN e testando sua existência
vetor5 <- c(7, NaN, 5, 99, 2)
is.nan(vetor5)
```

* Uma coisa importante a se notar é que um `NaN` é um `NA`, mas o contrário não é válido: um valor que não é um número é interpretado como um valor não disponível, mas um valor não disponível não é necessário um valor que não é um número.

```{r}
# para o vetor que possui um NA
is.na(vetor3) # existe um NA na terceira posição
is.nan(vetor3) # mas não existe um valor que não seja um número
# para o vetor que possui um NaN
is.na(vetor5) # existe um valor na segunda posição que não está disponível
is.nan(vetor5) # este valor na segunda posição é um NaN
```

# which
# which.max
# which.min
# setequal
# setdiff
# ifelse
# subset